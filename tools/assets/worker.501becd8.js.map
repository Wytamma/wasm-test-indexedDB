{"version":3,"file":"worker.501becd8.js","sources":["../node_modules/comlink/dist/esm/comlink.mjs","../node_modules/wasm-feature-detect/dist/esm/index.js","../src/worker.js"],"sourcesContent":["/**\r\n * Copyright 2019 Google Inc. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst proxyMarker = Symbol(\"Comlink.proxy\");\r\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\r\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\r\nconst throwMarker = Symbol(\"Comlink.thrown\");\r\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\r\n/**\r\n * Internal transfer handle to handle objects marked to proxy.\r\n */\r\nconst proxyTransferHandler = {\r\n    canHandle: (val) => isObject(val) && val[proxyMarker],\r\n    serialize(obj) {\r\n        const { port1, port2 } = new MessageChannel();\r\n        expose(obj, port1);\r\n        return [port2, [port2]];\r\n    },\r\n    deserialize(port) {\r\n        port.start();\r\n        return wrap(port);\r\n    },\r\n};\r\n/**\r\n * Internal transfer handler to handle thrown exceptions.\r\n */\r\nconst throwTransferHandler = {\r\n    canHandle: (value) => isObject(value) && throwMarker in value,\r\n    serialize({ value }) {\r\n        let serialized;\r\n        if (value instanceof Error) {\r\n            serialized = {\r\n                isError: true,\r\n                value: {\r\n                    message: value.message,\r\n                    name: value.name,\r\n                    stack: value.stack,\r\n                },\r\n            };\r\n        }\r\n        else {\r\n            serialized = { isError: false, value };\r\n        }\r\n        return [serialized, []];\r\n    },\r\n    deserialize(serialized) {\r\n        if (serialized.isError) {\r\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\r\n        }\r\n        throw serialized.value;\r\n    },\r\n};\r\n/**\r\n * Allows customizing the serialization of certain values.\r\n */\r\nconst transferHandlers = new Map([\r\n    [\"proxy\", proxyTransferHandler],\r\n    [\"throw\", throwTransferHandler],\r\n]);\r\nfunction expose(obj, ep = self) {\r\n    ep.addEventListener(\"message\", function callback(ev) {\r\n        if (!ev || !ev.data) {\r\n            return;\r\n        }\r\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\r\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\r\n        let returnValue;\r\n        try {\r\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\r\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\r\n            switch (type) {\r\n                case \"GET\" /* GET */:\r\n                    {\r\n                        returnValue = rawValue;\r\n                    }\r\n                    break;\r\n                case \"SET\" /* SET */:\r\n                    {\r\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\r\n                        returnValue = true;\r\n                    }\r\n                    break;\r\n                case \"APPLY\" /* APPLY */:\r\n                    {\r\n                        returnValue = rawValue.apply(parent, argumentList);\r\n                    }\r\n                    break;\r\n                case \"CONSTRUCT\" /* CONSTRUCT */:\r\n                    {\r\n                        const value = new rawValue(...argumentList);\r\n                        returnValue = proxy(value);\r\n                    }\r\n                    break;\r\n                case \"ENDPOINT\" /* ENDPOINT */:\r\n                    {\r\n                        const { port1, port2 } = new MessageChannel();\r\n                        expose(obj, port2);\r\n                        returnValue = transfer(port1, [port1]);\r\n                    }\r\n                    break;\r\n                case \"RELEASE\" /* RELEASE */:\r\n                    {\r\n                        returnValue = undefined;\r\n                    }\r\n                    break;\r\n                default:\r\n                    return;\r\n            }\r\n        }\r\n        catch (value) {\r\n            returnValue = { value, [throwMarker]: 0 };\r\n        }\r\n        Promise.resolve(returnValue)\r\n            .catch((value) => {\r\n            return { value, [throwMarker]: 0 };\r\n        })\r\n            .then((returnValue) => {\r\n            const [wireValue, transferables] = toWireValue(returnValue);\r\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\r\n            if (type === \"RELEASE\" /* RELEASE */) {\r\n                // detach and deactive after sending release response above.\r\n                ep.removeEventListener(\"message\", callback);\r\n                closeEndPoint(ep);\r\n            }\r\n        });\r\n    });\r\n    if (ep.start) {\r\n        ep.start();\r\n    }\r\n}\r\nfunction isMessagePort(endpoint) {\r\n    return endpoint.constructor.name === \"MessagePort\";\r\n}\r\nfunction closeEndPoint(endpoint) {\r\n    if (isMessagePort(endpoint))\r\n        endpoint.close();\r\n}\r\nfunction wrap(ep, target) {\r\n    return createProxy(ep, [], target);\r\n}\r\nfunction throwIfProxyReleased(isReleased) {\r\n    if (isReleased) {\r\n        throw new Error(\"Proxy has been released and is not useable\");\r\n    }\r\n}\r\nfunction createProxy(ep, path = [], target = function () { }) {\r\n    let isProxyReleased = false;\r\n    const proxy = new Proxy(target, {\r\n        get(_target, prop) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            if (prop === releaseProxy) {\r\n                return () => {\r\n                    return requestResponseMessage(ep, {\r\n                        type: \"RELEASE\" /* RELEASE */,\r\n                        path: path.map((p) => p.toString()),\r\n                    }).then(() => {\r\n                        closeEndPoint(ep);\r\n                        isProxyReleased = true;\r\n                    });\r\n                };\r\n            }\r\n            if (prop === \"then\") {\r\n                if (path.length === 0) {\r\n                    return { then: () => proxy };\r\n                }\r\n                const r = requestResponseMessage(ep, {\r\n                    type: \"GET\" /* GET */,\r\n                    path: path.map((p) => p.toString()),\r\n                }).then(fromWireValue);\r\n                return r.then.bind(r);\r\n            }\r\n            return createProxy(ep, [...path, prop]);\r\n        },\r\n        set(_target, prop, rawValue) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\r\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\r\n            const [value, transferables] = toWireValue(rawValue);\r\n            return requestResponseMessage(ep, {\r\n                type: \"SET\" /* SET */,\r\n                path: [...path, prop].map((p) => p.toString()),\r\n                value,\r\n            }, transferables).then(fromWireValue);\r\n        },\r\n        apply(_target, _thisArg, rawArgumentList) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            const last = path[path.length - 1];\r\n            if (last === createEndpoint) {\r\n                return requestResponseMessage(ep, {\r\n                    type: \"ENDPOINT\" /* ENDPOINT */,\r\n                }).then(fromWireValue);\r\n            }\r\n            // We just pretend that `bind()` didn’t happen.\r\n            if (last === \"bind\") {\r\n                return createProxy(ep, path.slice(0, -1));\r\n            }\r\n            const [argumentList, transferables] = processArguments(rawArgumentList);\r\n            return requestResponseMessage(ep, {\r\n                type: \"APPLY\" /* APPLY */,\r\n                path: path.map((p) => p.toString()),\r\n                argumentList,\r\n            }, transferables).then(fromWireValue);\r\n        },\r\n        construct(_target, rawArgumentList) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            const [argumentList, transferables] = processArguments(rawArgumentList);\r\n            return requestResponseMessage(ep, {\r\n                type: \"CONSTRUCT\" /* CONSTRUCT */,\r\n                path: path.map((p) => p.toString()),\r\n                argumentList,\r\n            }, transferables).then(fromWireValue);\r\n        },\r\n    });\r\n    return proxy;\r\n}\r\nfunction myFlat(arr) {\r\n    return Array.prototype.concat.apply([], arr);\r\n}\r\nfunction processArguments(argumentList) {\r\n    const processed = argumentList.map(toWireValue);\r\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\r\n}\r\nconst transferCache = new WeakMap();\r\nfunction transfer(obj, transfers) {\r\n    transferCache.set(obj, transfers);\r\n    return obj;\r\n}\r\nfunction proxy(obj) {\r\n    return Object.assign(obj, { [proxyMarker]: true });\r\n}\r\nfunction windowEndpoint(w, context = self, targetOrigin = \"*\") {\r\n    return {\r\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\r\n        addEventListener: context.addEventListener.bind(context),\r\n        removeEventListener: context.removeEventListener.bind(context),\r\n    };\r\n}\r\nfunction toWireValue(value) {\r\n    for (const [name, handler] of transferHandlers) {\r\n        if (handler.canHandle(value)) {\r\n            const [serializedValue, transferables] = handler.serialize(value);\r\n            return [\r\n                {\r\n                    type: \"HANDLER\" /* HANDLER */,\r\n                    name,\r\n                    value: serializedValue,\r\n                },\r\n                transferables,\r\n            ];\r\n        }\r\n    }\r\n    return [\r\n        {\r\n            type: \"RAW\" /* RAW */,\r\n            value,\r\n        },\r\n        transferCache.get(value) || [],\r\n    ];\r\n}\r\nfunction fromWireValue(value) {\r\n    switch (value.type) {\r\n        case \"HANDLER\" /* HANDLER */:\r\n            return transferHandlers.get(value.name).deserialize(value.value);\r\n        case \"RAW\" /* RAW */:\r\n            return value.value;\r\n    }\r\n}\r\nfunction requestResponseMessage(ep, msg, transfers) {\r\n    return new Promise((resolve) => {\r\n        const id = generateUUID();\r\n        ep.addEventListener(\"message\", function l(ev) {\r\n            if (!ev.data || !ev.data.id || ev.data.id !== id) {\r\n                return;\r\n            }\r\n            ep.removeEventListener(\"message\", l);\r\n            resolve(ev.data);\r\n        });\r\n        if (ep.start) {\r\n            ep.start();\r\n        }\r\n        ep.postMessage(Object.assign({ id }, msg), transfers);\r\n    });\r\n}\r\nfunction generateUUID() {\r\n    return new Array(4)\r\n        .fill(0)\r\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\r\n        .join(\"-\");\r\n}\n\nexport { createEndpoint, expose, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\n//# sourceMappingURL=comlink.mjs.map\n","export const bigInt=()=>(async e=>{try{return(await WebAssembly.instantiate(e)).instance.exports.b(BigInt(0))===BigInt(0)}catch(e){return!1}})(new Uint8Array([0,97,115,109,1,0,0,0,1,6,1,96,1,126,1,126,3,2,1,0,7,5,1,1,98,0,0,10,6,1,4,0,32,0,11])),bulkMemory=async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,3,1,0,1,10,14,1,12,0,65,0,65,0,65,0,252,10,0,0,11])),exceptions=async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,8,1,6,0,6,64,25,11,11])),multiValue=async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,6,1,96,0,2,127,127,3,2,1,0,10,8,1,6,0,65,0,65,0,11])),mutableGlobals=async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,2,8,1,1,97,1,98,3,127,1,6,6,1,127,1,65,0,11,7,5,1,1,97,3,1])),referenceTypes=async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,7,1,5,0,208,112,26,11])),saturatedFloatToInt=async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,12,1,10,0,67,0,0,0,0,252,0,26,11])),signExtensions=async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,8,1,6,0,65,0,192,26,11])),simd=async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,5,1,96,0,1,123,3,2,1,0,10,10,1,8,0,65,0,253,15,253,98,11])),tailCall=async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,6,1,4,0,18,0,11])),threads=()=>(async e=>{try{return\"undefined\"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(e)}catch(e){return!1}})(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]));\n","import { expose } from \"comlink\";\nimport { simd } from \"wasm-feature-detect\";\n\nconst LOADING_EAGER = \"eager\";\nconst LOADING_LAZY = \"lazy\";\n\n// Hardcode wasm features to avoid downloading a \"config.json\" for every tool.\n// As a result, adding a SIMD package to biowasm requires updating Aioli, but\n// there are very few packages that will require that.\nconst WASM_FEATURES = {\n\t\"ssw\": [\"simd\"],\n\t\"minimap2\": [\"simd\"]\n};\n\n// Main Aioli logic\nconst aioli = {\n\t// State\n\ttools: [],   // Tools that are available to use in this WebWorker\n\tconfig: {},  // See main.js for defaults\n\tfiles: [],   // File/Blob objects that represent local user files we mount to a virtual filesystem\n\tbase: {},    // Base module (e.g. aioli.tools[0]; not always [0], see init())\n\tfs: {},      // Base module's filesystem (e.g. aioli.tools[0].module.FS)\n\n\t// =========================================================================\n\t// Initialize the WebAssembly module(s)\n\t// Supports array of tool info, where each tool is represented by:\n\t// \t\t{\n\t// \t\t\ttool: \"samtools\",                             // Required\n\t// \t\t\tversion: \"1.10\",                              // Required\n\t// \t\t\tprogram: \"samtools\",                          // Optional, default=\"tool\" name. Only use this for tools with multiple subtools\n\t// \t\t\turlPrefix: \"https://cdn.biowasm.com/v3/...\",  // Optional, default=biowasm CDN. Only use for local biowasm development\n\t// \t\t\tloading: \"eager\",                             // Optional, default=\"eager\". Set to \"lazy\" to only load modules when they are used in exec()\n\t// \t\t\treinit: false,                                // Optional, default=\"false\". Set to \"true\" to reinitialize a module after each invocation\n\t// \t\t},\n\t// =========================================================================\n\tasync init() {\n\t\t// Expect at least 1 module\n\t\tif(aioli.tools.length === 0)\n\t\t\tthrow \"Expecting at least 1 tool.\";\n\n\t\t// Detect duplicate modules\n\t\tconst toolsUnique = new Set(aioli.tools.map(t => `${t.tool}/${t.program || t.tool}`));\n\t\tif(toolsUnique.size !== aioli.tools.length)\n\t\t\tthrow \"Found duplicate tools; can only have each tool/program combination at most once.\";\n\n\t\t// The base module cannot be reinitializable since we rely on its filesystem\n\t\t// to be stable (can remount files explicitly mounted via Aioli, but can't\n\t\t// remount files created by a tool). Try to find tool matching this criteria.\n\t\taioli.base = aioli.tools.find(t => t.reinit !== true);\n\t\tif(!aioli.base)\n\t\t\tthrow \"Could not find a tool with `reinit: false` to use as the base module. To fix this issue, include the tool `base/1.0.0` when initializing Aioli.\";\n\t\taioli.base.isBaseModule = true;\n\n\t\t// Set up base module first so that its filesystem is ready for the other\n\t\t// modules to mount in parallel\n\t\tawait this._setup(aioli.base);\n\n\t\t// Initialize all other modules\n\t\tawait this._initModules();\n\t\taioli._log(\"Ready\");\n\t\treturn true;\n\t},\n\n\t// Initialize all modules that should be eager-loaded (i.e. not lazy-loaded)\n\tasync _initModules() {\n\t\t// Initialize WebAssembly modules in parallel (though can't call importScripts in parallel)\n\t\tawait Promise.all(aioli.tools.map(this._setup));\n\n\t\t// Setup filesystems so that tools can access each other's sample data\n\t\tawait this._setupFS();\n\t},\n\n\t// =========================================================================\n\t// Mount files to the virtual file system\n\t// Supports <FileList>, <File>, <Blob>, strings, and string URLs:\n\t//\t\tmount(<FileList>)\n\t//\t\tmount([\n\t//\t\t\t<File>,\n\t// \t\t\t{ name: \"blob.txt\", data: <Blob> },\n\t//\t\t\t{ name: \"file.txt\", data: \"string\" },\n\t//\t\t\t{ name: \"hello.txt\", url: \"https://domain.com/...\" },\n\t//\t\t\t\"https://somefile.com\"\n\t//\t\t])\n\t// =========================================================================\n\tmount(files=[]) {\n\t\tconst dirData = `${aioli.config.dirShared}${aioli.config.dirData}`;\n\t\tconst dirMounted = `${aioli.config.dirShared}${aioli.config.dirMounted}`;\n\t\tlet toMountFiles = [], toMountURLs = [], mountedPaths = [];\n\n\t\t// Input validation: auto convert singletons to array for convenience\n\t\tif(!Array.isArray(files) && !(files instanceof FileList))\n\t\t\tfiles = [ files ];\n\t\taioli._log(`Mounting ${files.length} files`);\n\n\t\t// Sort files by type: File vs. Blob vs. URL\n\t\tfor(let file of files) {\n\t\t\t// Handle Files/Blobs/Data strings\n\t\t\t// String format: { name: \"filename.txt\", data: \"string data\" }\n\t\t\t// Blob format: { name: \"filename.txt\", data: new Blob(['blob data']) }\n\t\t\tif(file instanceof File || (file?.data instanceof Blob && file.name) || (typeof file?.data === \"string\" && file.name)) {\n\t\t\t\tif(typeof file?.data === \"string\")\n\t\t\t\t\tfile.data = new Blob([ file.data ], { type: \"text/plain\" });\n\t\t\t\ttoMountFiles.push(file);\n\n\t\t\t// Handle URLs\n\t\t\t// URL format: { name: \"filename.txt\", url: \"https://url\" }\n\t\t\t} else if(file.name && file.url) {\n\t\t\t\ttoMountURLs.push(file);\n\n\t\t\t// Handle URLs: mount \"https://website.com/some/path.js\" to \"/urls/website.com-some-path.js\")\n\t\t\t} else if(typeof file == \"string\" && file.startsWith(\"http\")) {\n\t\t\t\tfile = { url: file, name: file.split(\"//\").pop().replace(/\\//g, \"-\") };\n\t\t\t\ttoMountURLs.push(file);\n\n\t\t\t// Otherwise, incorrect data provided\n\t\t\t} else {\n\t\t\t\tthrow `Cannot mount file(s) specified. Must be a File, Blob, a URL string, or { name: \"file.txt\", data: \"string\" }.`;\n\t\t\t}\n\n\t\t\tmountedPaths.push(file.name);\n\t\t}\n\n\t\t// Unmount and remount files since WORKERFS is read-only (i.e. can only mount a folder once)\n\t\ttry {\n\t\t\taioli.fs.unmount(dirMounted);\n\t\t} catch(e) {}\n\n\t\t// Lazy-mount URLs, i.e. don't download any of them, but will automatically do\n\t\t// HTTP Range requests when a tool requests a subset of bytes from a file.\n\t\tfor(let file of toMountURLs)\n\t\t\taioli.fs.createLazyFile(dirData, file.name, file.url, true, true);\n\n\t\t// Mount files (save for later for the next time we need to remount them)\n\t\taioli.files = aioli.files.concat(toMountFiles);\n\t\taioli.base.module.FS.mount(aioli.base.module.WORKERFS, {\n\t\t\tfiles: aioli.files.filter(f => f instanceof File),\n\t\t\tblobs: aioli.files.filter(f => f?.data instanceof Blob)\n\t\t}, dirMounted);\n\n\t\t// Create symlinks for convenience. The folder \"dirMounted\" is a WORKERFS, which is read-only. By adding\n\t\t// symlinks to a separate writeable folder \"dirData\", we can support commands like \"samtools index abc.bam\",\n\t\t// which create a \"abc.bam.bai\" file in the same path where the .bam file is created.\n\t\ttoMountFiles.map(file => {\n\t\t\tconst oldpath = `${dirMounted}/${file.name}`;\n\t\t\tconst newpath = `${dirData}/${file.name}`;\n\t\t\ttry {\n\t\t\t\taioli.fs.unlink(newpath);\n\t\t\t} catch(e) {}\n\t\t\taioli._log(`Creating symlink: ${newpath} --> ${oldpath}`)\n\n\t\t\t// Create symlink within first module's filesystem (note: tools[0] is always the \"base\" biowasm module)\n\t\t\taioli.fs.symlink(oldpath, newpath);\n\t\t});\n\n\t\treturn mountedPaths.map(path => `${dirData}/${path}`);\n\t},\n\n\t// =========================================================================\n\t// Execute a command\n\t// =========================================================================\n\tasync exec(command, args=null) {\n\t\t// Input validation\n\t\taioli._log(`Executing %c${command}%c args=${args}`, \"color:darkblue; font-weight:bold\", \"\");\n\t\tif(!command)\n\t\t\tthrow \"Expecting a command\";\n\t\t// Extract tool name and arguments\n\t\tlet toolName = command;\n\t\tif(args == null) {\n\t\t\targs = command.split(\" \");\n\t\t\ttoolName = args.shift();\n\t\t}\n\n\t\t// Does it match a program we've already initialized?\n\t\tconst tool = aioli.tools.find(t => {\n\t\t\tlet tmpToolName = toolName;\n\t\t\t// Take special WebAssembly features into account\n\t\t\tif(t?.features?.simd === true)\n\t\t\t\ttmpToolName = `${tmpToolName}-simd`;\n\t\t\treturn t.program == tmpToolName;\n\t\t});\n\t\tif(tool == null)\n\t\t\tthrow `Program ${toolName} not found.`;\n\t\t// Prepare tool\n\t\ttool.stdout = \"\";\n\t\ttool.stderr = \"\";\n\n\t\t// If this is a lazy-loaded module, load it now by setting it to eager loading.\n\t\t// Note that calling _initModules will only load modules that haven't yet been loaded.\n\t\tif(tool.loading == LOADING_LAZY) {\n\t\t\ttool.loading = LOADING_EAGER;\n\t\t\tawait this._initModules();\n\t\t}\n\n\t\t// Run command. Stdout/Stderr will be saved to \"tool.stdout\"/\"tool.stderr\" (see \"print\" and \"printErr\" above)\n\t\ttry {\n\t\t\ttool.module.callMain(args);\n\t\t} catch (error) {\n\t\t\tconsole.error(error);\n\t\t}\n\n\t\t// Flush stdout/stderr to make sure we got everything. Otherwise, if use a command like \n\t\t// `bcftools query -f \"%ALT\" variants.bcf`, it won't output anything until the next\n\t\t// invocation of that command!\n\t\ttry {\n\t\t\ttool.module.FS.close( tool.module.FS.streams[1] );\n\t\t\ttool.module.FS.close( tool.module.FS.streams[2] );\n\t\t} catch (error) {}\n\t\t// Re-open stdout/stderr (fix error \"error closing standard output: -1\")\n\t\ttool.module.FS.streams[1] = tool.module.FS.open(\"/dev/stdout\", \"w\");\n\t\ttool.module.FS.streams[2] = tool.module.FS.open(\"/dev/stderr\", \"w\");\n\n\t\t// Return output, either stdout/stderr interleaved, or each one separately\n\t\tlet result = { stdout: tool.stdout, stderr: tool.stderr };\n\t\tif(aioli.config.printInterleaved)\n\t\t\tresult = tool.stdout;\n\n\t\t// Reinitialize module after done? This is useful for tools that don't properly reset their global state the\n\t\t// second time the `main()` function is called.\n\t\tif(tool.reinit === true) {\n\t\t\tawait this.reinit(tool.tool);\n\t\t}\n\n\t\treturn result;\n\t},\n\n\t// =========================================================================\n\t// Utility functions for common file operations\n\t// =========================================================================\n\tcat(path) {\n\t\treturn aioli._fileop(\"cat\", path);\n\t},\n\n\tls(path) {\n\t\treturn aioli._fileop(\"ls\", path);\n\t},\n\n\tdownload(path) {\n\t\treturn aioli._fileop(\"download\", path);\n\t},\n\n\tpwd() {\n\t\treturn aioli.fs.cwd();\n\t},\n\n\tcd(path) {\n\t\tfor(let tool of aioli.tools) {\n\t\t\t// Ignore modules that haven't been initialized yet (i.e. lazy-loaded modules)\n\t\t\tconst module = tool.module;\n\t\t\tif(!module)\n\t\t\t\tcontinue;\n\t\t\ttool.module.FS.chdir(path);\n\t\t}\n\t},\n\n\tmkdir(path) {\n\t\taioli.fs.mkdir(path);\n\t\treturn true;\n\t},\n\n\tread({ path, length, flag=\"r\", offset=0, position=0 }) {\n\t\tconst stream = aioli.fs.open(path, flag);\n\t\tconst buffer = new Uint8Array(length);\n\t\taioli.fs.read(stream, buffer, offset, length, position);\n\t\taioli.fs.close(stream);\n\t\treturn buffer;\n\t},\n\n\twrite({ path, buffer, flag=\"w+\", offset=0, position=0 }) {\n\t\tconst stream = aioli.fs.open(path, flag);\n\t\taioli.fs.write(stream, buffer, offset, buffer.length, position);\n\t\taioli.fs.close(stream);\n\t},\n\n\t// =========================================================================\n\t// Reinitialize a tool\n\t// =========================================================================\n\tasync reinit(toolName) {\n\t\tconst tool = aioli.tools.find(t => t.tool == toolName);\n\t\t// Save state before reinitializing\n\t\tconst pwd = aioli.base.module.FS.cwd();\n\n\t\t// Reinitialize module\n\t\tObject.assign(tool, tool.config);\n\t\ttool.ready = false;\n\t\tawait this.init();\n\t\t// If reinitialized the base module, remount previously mounted files\n\t\tif(tool.isBaseModule)\n\t\t\tthis.mount();\n\n\t\t// Go back to previous folder\n\t\tthis.cd(pwd);\n\t},\n\n\t// =========================================================================\n\t// Stdin management: Use `CLI.stdin = \"some text\"` to set stdin before calling a tool\n\t// =========================================================================\n\t_stdinTxt: \"\",\n\t_stdinPtr: 0,\n\tget stdin() {\n\t\treturn aioli._stdinTxt;\n\t},\n\tset stdin(txt = \"\") {\n\t\taioli._log(`Setting stdin to %c${txt}%c`, \"color:darkblue\", \"\");\n\t\taioli._stdinTxt = txt;\n\t\taioli._stdinPtr = 0;\n\t},\n\n\t// =========================================================================\n\t// Initialize a tool\n\t// =========================================================================\n\tasync _setup(tool) {\n\t\tif(tool.ready)\n\t\t\treturn;\n\t\taioli._log(`Setting up ${tool.tool} (base = ${tool.isBaseModule === true})...`);\n\n\t\t// Save original config in case need them to reinitialize (use Object.assign to avoid ref changes)\n\t\ttool.config = Object.assign({}, tool);\n\n\t\t// -----------------------------------------------------------------\n\t\t// Set default settings\n\t\t// -----------------------------------------------------------------\n\n\t\t// By default, use the CDN path, but also accept custom paths for each tool\n\t\tif(!tool.urlPrefix)\n\t\t\ttool.urlPrefix = `${aioli.config.urlCDN}/${tool.tool}/${tool.version}`;\n\n\t\t// In most cases, the program is the same as the tool name, but there are exceptions. For example, for the\n\t\t// tool \"seq-align\", program can be \"needleman_wunsch\", \"smith_waterman\", or \"lcs\".\n\t\tif(!tool.program)\n\t\t\ttool.program = tool.tool;\n\n\t\t// SIMD isn't enabled on all browsers. Load the right .wasm file based on the user's browser\n\t\tif(!tool.features) {\n\t\t\ttool.features = {};\n\t\t\tconst wasmFeatures = WASM_FEATURES[tool.program] || [];\n\t\t\tif(wasmFeatures.includes(\"simd\")) {\n\t\t\t\tif(await simd()) {\n\t\t\t\t\ttool.program += \"-simd\";\n\t\t\t\t\ttool.features.simd = true;\n\t\t\t\t} else {\n\t\t\t\t\taioli._log(`WebAssembly SIMD is not supported in this browser; will load non-SIMD version of ${tool.program}.`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// First module can't be lazy-loaded because that's where the main filesystem is mounted\n\t\tif(tool.isBaseModule)\n\t\t\ttool.loading = LOADING_EAGER;\n\t\t// If want lazy loading, don't go any further\n\t\tif(tool.loading === LOADING_LAZY) {\n\t\t\taioli._log(`Will lazy-load ${tool.tool}; skipping initialization.`)\n\t\t\treturn;\n\t\t}\n\n\t\t// -----------------------------------------------------------------\n\t\t// Import the WebAssembly module\n\t\t// -----------------------------------------------------------------\n\n\t\t// All biowasm modules export the variable \"Module\" so assign it\n\t\tself.importScripts(`${tool.urlPrefix}/${tool.program}.js`);\n\n\t\t// Initialize the Emscripten module and pass along settings to overwrite\n\t\ttool.module = await Module({\n\t\t\t// By default, tool name is hardcoded as \"./this.program\"\n\t\t\tthisProgram: tool.program,\n\t\t\t// Used by Emscripten to find path to .wasm / .data files\n\t\t\tlocateFile: (path, prefix) => `${tool.urlPrefix}/${path}`,\n\t\t\t// Custom stdin handling\n\t\t\tstdin: () => {\n\t\t\t\tif(aioli._stdinPtr < aioli.stdin.length)\n\t\t\t\t\treturn aioli.stdin.charCodeAt(aioli._stdinPtr++);\n\t\t\t\telse {\n\t\t\t\t\taioli.stdin = \"\";\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t},\n\t\t\t// Setup print functions to store stdout/stderr output\n\t\t\tprint: text => {\n\t\t\t\tif(aioli.config.printStream) {\n\t\t\t\t\tpostMessage({\n\t\t\t\t\t\ttype: \"biowasm\",\n\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\tstdout: text,\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\ttool.stdout += text + \"\\n\";\n\t\t\t\t}\n\t\t\t\t// reset the text so we don't store it in memory\n\t\t\t\ttext = null;\n\t\t\t},\n\t\t\tprintErr: text => {\n\t\t\t\tconst destination = aioli.config.printInterleaved ? \"stdout\" : \"stderr\";\n\t\t\t\tif(aioli.config.printStream) {\n\t\t\t\t\tpostMessage({\n\t\t\t\t\t\ttype: \"biowasm\",\n\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t[destination]: text,\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\ttool[destination] += text + \"\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// -----------------------------------------------------------------\n\t\t// Setup file system\n\t\t// -----------------------------------------------------------------\n\n\t\tconst FS = tool.module.FS;\n\n\t\t// The base module has the main filesystem, which other tools will mount\n\t\tif(tool.isBaseModule) {\n\t\t\taioli._log(`Setting up ${tool.tool} with base module filesystem...`);\n\t\t\tFS.mkdir(aioli.config.dirShared, 0o777);\n\t\t\tFS.mkdir(`${aioli.config.dirShared}/${aioli.config.dirData}`, 0o777);\n\t\t\tFS.mkdir(`${aioli.config.dirShared}/${aioli.config.dirMounted}`, 0o777);\n\t\t\tFS.chdir(`${aioli.config.dirShared}/${aioli.config.dirData}`);\n\t\t\taioli.fs = FS;\n\n\t\t// Non-base modules should proxy base module's FS\n\t\t} else {\n\t\t\taioli._log(`Setting up ${tool.tool} with filesystem...`)\n\t\t\t// PROXYFS allows us to point \"/shared\" to the base module's filesystem \"/shared\"\n\t\t\tFS.mkdir(aioli.config.dirShared);\n\t\t\tFS.mount(tool.module.PROXYFS, {\n\t\t\t\troot: aioli.config.dirShared,\n\t\t\t\tfs: aioli.fs\n\t\t\t}, aioli.config.dirShared);\n\n\t\t\t// Set the working directory to be the same as the base module so we keep them in sync.\n\t\t\t// If all modules are eager loaded, this will just be /shared/data, but if this module\n\t\t\t// is lazy loaded, it should be whichever folder the base module is currently at!\n\t\t\tFS.chdir(aioli.fs.cwd());\n\t\t}\n\n\t\t// -----------------------------------------------------------------\n\t\t// Initialize variables\n\t\t// -----------------------------------------------------------------\n\n\t\ttool.stdout = \"\";\n\t\ttool.stderr = \"\";\n\t\ttool.ready = true;\n\t},\n\n\t// Some tools have preloaded files mounted to their filesystems to hold sample data (e.g. /samtools/examples/).\n\t// By default, those are only accessible from the filesystem of the respective tool. Here, we want to allow\n\t// other modules to also have access to those sample data files.\n\tasync _setupFS() {\n\t\t// Mount every tool's sample data onto the base module (including base module's own sample data)\n\t\tconst fsDst = aioli.fs;\n\t\tfor(let tool of aioli.tools) {\n\t\t\t// Ignore lazy-loaded modules that haven't been initialized yet\n\t\t\tif(!tool.ready)\n\t\t\t\tcontinue;\n\n\t\t\t// Skip if the source path doesn't exist or if the destination path has already been created\n\t\t\tconst fsSrc = tool.module.FS;\n\t\t\tconst pathSrc = `/${tool.tool}`;\n\t\t\tconst pathDst = `${aioli.config.dirShared}${pathSrc}`;\n\t\t\tif(!fsSrc.analyzePath(pathSrc).exists || fsDst.analyzePath(pathDst).exists)\n\t\t\t\tcontinue;\n\n\t\t\taioli._log(`Mounting ${pathSrc} onto ${aioli.base.tool} filesystem at ${pathDst}`);\n\t\t\tfsDst.mkdir(pathDst);\n\t\t\tfsDst.mount(aioli.base.module.PROXYFS, {\n\t\t\t\troot: pathSrc,\n\t\t\t\tfs: fsSrc\n\t\t\t}, pathDst);\n\t\t}\n\t},\n\n\t// =========================================================================\n\t// Utilities\n\t// =========================================================================\n\t// Common file operations\n\t_fileop(operation, path) {\n\t\taioli._log(`Running ${operation} ${path}`);\n\n\t\t// Check whether the file exists\n\t\tconst info = aioli.fs.analyzePath(path);\n\t\tif(!info.exists) {\n\t\t\taioli._log(`File ${path} not found.`);\n\t\t\treturn false;\n\t\t}\n\n\t\t// Execute operation of interest\n\t\tswitch (operation) {\n\t\t\tcase \"cat\":\n\t\t\t\treturn aioli.fs.readFile(path, { encoding: \"utf8\" });\n\n\t\t\tcase \"ls\":\n\t\t\t\tif(aioli.fs.isFile(info.object.mode))\n\t\t\t\t\treturn aioli.fs.stat(path);\n\t\t\t\treturn aioli.fs.readdir(path);\n\n\t\t\tcase \"download\":\n\t\t\t\tconst blob = new Blob([ this.cat(path) ]);\n\t\t\t\treturn URL.createObjectURL(blob);\n\t\t}\n\n\t\treturn false;\n\t},\n\n\t// Log if debug enabled\n\t_log(message) {\n\t\tif(!aioli.config.debug)\n\t\t\treturn;\n\n\t\t// Support custom %c arguments\n\t\tlet args = [...arguments];\n\t\targs.shift();\n\t\tconsole.log(`%c[WebWorker]%c ${message}`, \"font-weight:bold\", \"\", ...args);\n\t}\n};\n\nexpose(aioli);\n"],"names":["obj","returnValue","proxy"],"mappings":"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"}